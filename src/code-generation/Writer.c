#include "Writer.h"

#include <inttypes.h>
#include <stdio.h>
#include <string.h>

#include "StringUtils.h"
#include "data-structures/MemoryStream.h"

#define INDENT_WIDTH 4
#define INDENT_STRING "    "

static const char watermark[] =
	"\n"
	"      generated by                 /$$     /$$                \n"
	"                                  | $$    | $$                \n"
	"    /$$$$$$$  /$$$$$$$ /$$   /$$ /$$$$$$  | $$$$$$$   /$$$$$$ \n"
	"   /$$_____/ /$$_____/| $$  | $$|_  $$_/  | $$__  $$ /$$__  $$\n"
	"  |  $$$$$$ | $$      | $$  | $$  | $$    | $$  \\ $$| $$$$$$$$\n"
	"   \\____  $$| $$      | $$  | $$  | $$ /$$| $$  | $$| $$_____/\n"
	"   /$$$$$$$/|  $$$$$$$|  $$$$$$$  |  $$$$/| $$  | $$|  $$$$$$$\n"
	"  |_______/  \\_______/ \\____  $$   \\___/  |__/  |__/ \\_______/\n"
	"                       /$$  | $$                              \n"
	"                      |  $$$$$$/                              \n"
	"                       \\______/                               \n";

static MemoryStream* sections;
static MemoryStream* descriptionLines;

static int indentationLevel;

static const int binaryPrecedence[] = {
	[Binary_Exponentiation] = 18,
	[Binary_Modulo] = 17,
	[Binary_LeftShift] = 16,
	[Binary_RightShift] = 16,
	[Binary_Multiply] = 15,
	[Binary_Divide] = 15,
	[Binary_Add] = 14,
	[Binary_Subtract] = 14,

	[Binary_BitOr] = 13,
	[Binary_BitAnd] = 12,
	[Binary_XOR] = 11,

	[Binary_IsEqual] = 10,
	[Binary_NotEqual] = 10,
	[Binary_LessThan] = 10,
	[Binary_GreaterThan] = 10,
	[Binary_LessOrEqual] = 10,
	[Binary_GreaterOrEqual] = 10,

	[Binary_BoolOr] = 9,
	[Binary_BoolAnd] = 8,

	[Binary_Assignment] = 7,
};

static void WriteUInt64(uint64_t integer, MemoryStream* stream)
{
	char string[INT64_MAX_CHARS + 1];
	int numChars = snprintf(string, sizeof(string), "%" PRIu64, integer);
	if (numChars < 1)
		UNREACHABLE();
	StreamWrite(stream, string, (size_t)numChars);
}

static void WriteUniqueName(int uniqueName, MemoryStream* stream)
{
	ASSERT(uniqueName > 0);
	char string[INT64_MAX_CHARS + 1];
	int numChars = snprintf(string, sizeof(string), "%d", uniqueName);
	if (numChars < 1)
		UNREACHABLE();
	StreamWrite(stream, string, (size_t)numChars);
}

static void WriteString(const char* str, MemoryStream* stream)
{
	const size_t length = strlen(str);
	if (length == 0)
		return;

	StreamWrite(stream, str, length);

	if (str[length - 1] == '\n')
	{
		for (int i = 0; i < indentationLevel; ++i)
			StreamWrite(stream, INDENT_STRING, INDENT_WIDTH);
	}
}

static void WriteChar(char chr, MemoryStream* stream)
{
	StreamWriteByte(stream, chr);

	if (chr == '\n')
	{
		for (int i = 0; i < indentationLevel; ++i)
			StreamWrite(stream, INDENT_STRING, INDENT_WIDTH);
	}
}

static void PushIndent(MemoryStream* stream)
{
	StreamWrite(stream, INDENT_STRING, INDENT_WIDTH);
	indentationLevel++;
}

static void PopIndent(MemoryStream* stream)
{
	const Buffer lastChars = StreamRewindRead(stream, INDENT_WIDTH);
	if (memcmp(INDENT_STRING, lastChars.buffer, INDENT_WIDTH) == 0)
		StreamRewind(stream, INDENT_WIDTH);
	indentationLevel--;
}

static void VisitExpression(NodePtr node, const NodePtr* parentExpr);
static void VisitStatement(const NodePtr* node);

static void VisitFunctionCall(FuncCallExpr* funcCall)
{
	NodePtr funcCallNode = (NodePtr){.ptr = funcCall, .type = Node_FunctionCall};

	VisitExpression(funcCall->baseExpr, &funcCallNode);

	WriteChar('(', sections);
	for (size_t i = 0; i < funcCall->arguments.length; ++i)
	{
		VisitExpression(*(NodePtr*)funcCall->arguments.array[i], &funcCallNode);

		if (i < funcCall->arguments.length - 1)
			WriteString(", ", sections);
	}
	WriteChar(')', sections);
}

static void VisitLiteralExpression(LiteralExpr* literal)
{
	switch (literal->type)
	{
	case Literal_Number: WriteString(literal->number, sections); break;
	case Literal_String:
		WriteChar('\"', sections);
		WriteString(literal->string, sections);
		WriteChar('\"', sections);
		break;
	case Literal_Char:
		WriteChar('\'', sections);
		WriteString(literal->multiChar, sections);
		WriteChar('\'', sections);
		break;
	default: INVALID_VALUE(literal->type);
	}
}

static void VisitBinaryExpression(BinaryExpr* binary, const NodePtr* parentExpr)
{
	char* operator;
	switch (binary->operatorType)
	{
	case Binary_BoolAnd: operator= "&&"; break;
	case Binary_BoolOr: operator= "||"; break;
	case Binary_IsEqual: operator= "=="; break;
	case Binary_NotEqual: operator= "!="; break;
	case Binary_GreaterThan: operator= ">"; break;
	case Binary_GreaterOrEqual: operator= ">="; break;
	case Binary_LessThan: operator= "<"; break;
	case Binary_LessOrEqual: operator= "<="; break;

	case Binary_BitAnd: operator= "&"; break;
	case Binary_BitOr: operator= "|"; break;
	case Binary_XOR: operator= "~"; break;

	case Binary_Add: operator= "+"; break;
	case Binary_Subtract: operator= "-"; break;
	case Binary_Multiply: operator= "*"; break;
	case Binary_Divide: operator= "/"; break;
	case Binary_Exponentiation: operator= "^"; break;
	case Binary_Modulo: operator= "%"; break;
	case Binary_LeftShift: operator= "<<"; break;
	case Binary_RightShift: operator= ">>"; break;

	case Binary_Assignment: operator= "="; break;
	default: INVALID_VALUE(binary->operatorType);
	}

	bool writeBrackets = true;
	if (parentExpr == NULL ||
		parentExpr->type == Node_FunctionCall)
	{
		writeBrackets = false;
	}
	else if (parentExpr->type == Node_Binary)
	{
		BinaryExpr* parent = parentExpr->ptr;
		if (binaryPrecedence[binary->operatorType] > binaryPrecedence[parent->operatorType])
			writeBrackets = false;
	}

	NodePtr binaryNode = (NodePtr){.ptr = binary, .type = Node_Binary};

	if (writeBrackets) WriteChar('(', sections);
	VisitExpression(binary->left, &binaryNode);
	WriteChar(' ', sections);
	WriteString(operator, sections);
	WriteChar(' ', sections);
	VisitExpression(binary->right, &binaryNode);
	if (writeBrackets) WriteChar(')', sections);
}

static void VisitUnaryExpression(UnaryExpr* unary)
{
	char* operator;
	switch (unary->operatorType)
	{
	case Unary_Plus: operator= "+"; break;
	case Unary_Minus: operator= "-"; break;
	case Unary_Negate: operator= "!"; break;
	default: INVALID_VALUE(unary->operatorType);
	}

	WriteString(operator, sections);
	VisitExpression(unary->expression, &(NodePtr){.ptr = unary, .type = Node_Unary});
}

static void VisitSubscriptExpression(SubscriptExpr* subscript)
{
	NodePtr node = (NodePtr){.ptr = subscript, .type = Node_Subscript};

	VisitExpression(subscript->baseExpr, &node);
	WriteChar('[', sections);
	VisitExpression(subscript->indexExpr, &node);
	WriteChar(']', sections);
}

static bool IsExternal(const MemberAccessExpr* identifier)
{
	if (identifier->funcReference != NULL)
		return identifier->funcReference->modifiers.externalValue;
	if (identifier->varReference != NULL)
		return identifier->varReference->modifiers.externalValue;
	UNREACHABLE();
}

static int GetUniqueName(const MemberAccessExpr* identifier)
{
	if (identifier->funcReference != NULL)
		return identifier->funcReference->uniqueName;
	if (identifier->varReference != NULL)
		return identifier->varReference->uniqueName;
	UNREACHABLE();
}

static char* GetName(const MemberAccessExpr* identifier, bool external)
{
	if (identifier->funcReference != NULL)
		return external && identifier->funcReference->externalName
				   ? identifier->funcReference->externalName
				   : identifier->funcReference->name;
	if (identifier->typeReference != NULL)
		return identifier->typeReference->name;
	if (identifier->varReference != NULL)
		return external && identifier->varReference->externalName
				   ? identifier->varReference->externalName
				   : identifier->varReference->name;
	UNREACHABLE();
}

static void VisitMemberAccessExpression(const MemberAccessExpr* identifier)
{
	WriteString(GetName(identifier, IsExternal(identifier)), sections);
	if (!IsExternal(identifier))
	{
		WriteChar('_', sections);
		WriteUniqueName(GetUniqueName(identifier), sections);
	}
}

static void VisitExpression(const NodePtr node, const NodePtr* parentExpr)
{
	switch (node.type)
	{
	case Node_Binary: VisitBinaryExpression(node.ptr, parentExpr); break;
	case Node_Unary: VisitUnaryExpression(node.ptr); break;
	case Node_MemberAccess: VisitMemberAccessExpression(node.ptr); break;
	case Node_Literal: VisitLiteralExpression(node.ptr); break;
	case Node_FunctionCall: VisitFunctionCall(node.ptr); break;
	case Node_Subscript: VisitSubscriptExpression(node.ptr); break;
	default: INVALID_VALUE(node.type);
	}
}

static void VisitVariableDeclaration(VarDeclStmt* varDecl)
{
	ASSERT(varDecl != NULL);
	if (varDecl->modifiers.externalValue)
		return;

	ASSERT(varDecl->initializer.ptr != NULL);

	VisitBinaryExpression(
		&(BinaryExpr){
			.lineNumber = -1,
			.operatorType = Binary_Assignment,
			.right = varDecl->initializer,
			.left = (NodePtr){
				&(MemberAccessExpr){
					.lineNumber = -1,
					.start = NULL_NODE,
					.identifiers.array = NULL,
					.funcReference = NULL,
					.typeReference = NULL,
					.varReference = varDecl,
					.parentReference = NULL,
				},
				Node_MemberAccess},
		},
		NULL);
	WriteString(";\n", sections);
}

static void VisitBlock(const BlockStmt* block, const bool semicolon)
{
	WriteString("(\n", sections);
	PushIndent(sections);
	bool hasStatements = false;
	for (size_t i = 0; i < block->statements.length; ++i)
	{
		NodePtr* node = block->statements.array[i];
		VisitStatement(node);
		if (node->ptr)
			hasStatements = true;
	}
	if (!hasStatements)
		WriteString("0;\n", sections);
	PopIndent(sections);
	WriteChar(')', sections);
	if (semicolon) WriteString(";\n", sections);
}

static void VisitFunctionDeclaration(const FuncDeclStmt* funcDecl)
{
	if (funcDecl->modifiers.externalValue)
		return;

	WriteString("function ", sections);
	WriteString(funcDecl->name, sections);
	WriteChar('_', sections);
	WriteUniqueName(funcDecl->uniqueName, sections);

	WriteChar('(', sections);
	for (size_t i = 0; i < funcDecl->parameters.length; ++i)
	{
		const NodePtr* node = funcDecl->parameters.array[i];

		ASSERT(node->type == Node_VariableDeclaration);
		const VarDeclStmt* varDecl = node->ptr;
		WriteString(varDecl->name, sections);
		WriteChar('_', sections);
		WriteUniqueName(varDecl->uniqueName, sections);

		if (i < funcDecl->parameters.length - 1)
			WriteString(", ", sections);
	}
	WriteString(")\n", sections);

	ASSERT(funcDecl->block.type == Node_BlockStatement);
	VisitBlock(funcDecl->block.ptr, true);
}

static void VisitIfStatement(const IfStmt* ifStmt, bool semicolon)
{
	VisitExpression(ifStmt->expr, NULL);
	WriteString(" ? ", sections);

	if (!ifStmt->falseStmt.ptr)
		WriteChar('\n', sections);

	ASSERT(ifStmt->trueStmt.type == Node_BlockStatement);
	VisitBlock(ifStmt->trueStmt.ptr, false);

	if (ifStmt->falseStmt.ptr)
	{
		WriteString(" : ", sections);

		ASSERT(ifStmt->falseStmt.type == Node_BlockStatement);
		BlockStmt* block = ifStmt->falseStmt.ptr;
		if (block->statements.length == 1 &&
			((NodePtr*)block->statements.array[0])->type == Node_If)
		{
			IfStmt* ifStmt = ((NodePtr*)block->statements.array[0])->ptr;
			VisitIfStatement(ifStmt, false);
		}
		else
			VisitBlock(ifStmt->falseStmt.ptr, false);
	}

	if (semicolon)
		WriteString(";\n", sections);
}

static void VisitWhileStatement(const WhileStmt* whileStmt)
{
	WriteString("while (", sections);
	VisitExpression(whileStmt->expr, NULL);
	WriteString(")\n", sections);

	ASSERT(whileStmt->stmt.type == Node_BlockStatement);
	VisitBlock(whileStmt->stmt.ptr, true);
}

static void VisitStatement(const NodePtr* node)
{
	switch (node->type)
	{
	case Node_FunctionDeclaration:
	{
		VisitFunctionDeclaration(node->ptr);
		break;
	}
	case Node_VariableDeclaration:
	{
		VisitVariableDeclaration(node->ptr);
		break;
	}
	case Node_ExpressionStatement:
	{
		const ExpressionStmt* expressionStmt = node->ptr;
		VisitExpression(expressionStmt->expr, NULL);
		WriteString(";\n", sections);
		break;
	}
	case Node_BlockStatement:
	{
		VisitBlock(node->ptr, true);
		break;
	}
	case Node_If:
	{
		VisitIfStatement(node->ptr, true);
		break;
	}
	case Node_While:
	{
		VisitWhileStatement(node->ptr);
		break;
	}
	case Node_Null:
		break;
	default: INVALID_VALUE(node->type);
	}
}

static void WriteSection(const SectionStmt* section)
{
	const size_t start = StreamGetPosition(sections);

	const char* sectionText = NULL;
	switch (section->sectionType)
	{
	case Section_Init: sectionText = "init"; break;
	case Section_Block: sectionText = "block"; break;
	case Section_Sample: sectionText = "sample"; break;
	case Section_Serialize: sectionText = "serialize"; break;
	case Section_Slider: sectionText = "slider"; break;
	case Section_GFX: sectionText = "gfx"; break;
	default: INVALID_VALUE(section->sectionType);
	}

	WriteChar('@', sections);
	WriteString(sectionText, sections);

	if (section->sectionType == Section_GFX)
	{
		if (section->width)
		{
			WriteChar(' ', sections);
			WriteString(section->width, sections);
		}
		if (section->height)
		{
			if (!section->width)
				WriteString(" 0", sections);

			WriteChar(' ', sections);
			WriteString(section->height, sections);
		}
	}

	WriteChar('\n', sections);

	const size_t statementsPos = StreamGetPosition(sections);

	ASSERT(section->block.type == Node_BlockStatement);
	const BlockStmt* block = section->block.ptr;
	for (size_t i = 0; i < block->statements.length; ++i)
		VisitStatement(block->statements.array[i]);

	if (statementsPos == StreamGetPosition(sections))
		StreamRewind(sections, StreamGetPosition(sections) - start);
	else
		WriteChar('\n', sections);
}

static void WriteSlider(const InputStmt* slider)
{
	WriteString("slider", descriptionLines);
	WriteUInt64(slider->sliderNumber, descriptionLines);
	WriteChar(':', descriptionLines);

	ASSERT(slider->varDecl.type == Node_VariableDeclaration);
	WriteString(slider->name, descriptionLines);
	WriteChar('_', descriptionLines);
	WriteUniqueName(((VarDeclStmt*)slider->varDecl.ptr)->uniqueName, descriptionLines);
	WriteChar('=', descriptionLines);
	WriteString(slider->defaultValue, descriptionLines);

	WriteChar('<', descriptionLines);
	WriteString(slider->min, descriptionLines);
	WriteChar(',', descriptionLines);
	WriteString(slider->max, descriptionLines);
	WriteChar(',', descriptionLines);
	WriteString(slider->increment, descriptionLines);
	if (slider->shape == SliderShape_Logarithmic)
	{
		WriteString(":log", descriptionLines);
		if (slider->linear_automation)
			WriteChar('!', descriptionLines);
		WriteChar('=', descriptionLines);
		WriteString(slider->midpoint, descriptionLines);
	}
	else if (slider->shape == SliderShape_Exponential)
	{
		WriteString(":sqr", descriptionLines);
		if (slider->linear_automation)
			WriteChar('!', descriptionLines);
		WriteChar('=', descriptionLines);
		WriteString(slider->exponent, descriptionLines);
	}
	WriteChar('>', descriptionLines);

	if (slider->hidden)
		WriteChar('-', descriptionLines);
	WriteString(slider->description, descriptionLines);

	WriteChar('\n', descriptionLines);
}

static void WriteModule(const ModuleNode* module)
{
	const size_t start = StreamGetPosition(sections);

	if (module->statements.length != 0)
	{
		WriteString("// Module: ", sections);
		WriteString(module->moduleName, sections);
		WriteChar('\n', sections);
	}

	const size_t statementsPos = StreamGetPosition(sections);

	for (size_t i = 0; i < module->statements.length; ++i)
	{
		const NodePtr* stmt = module->statements.array[i];
		switch (stmt->type)
		{
		case Node_Section:
			WriteSection(stmt->ptr);
			break;
		case Node_Input:
			WriteSlider(stmt->ptr);
			break;
		case Node_Import:
		case Node_Null:
			break;
		default: INVALID_VALUE(stmt->type);
		}
	}

	if (statementsPos == StreamGetPosition(sections))
		StreamRewind(sections, StreamGetPosition(sections) - start);
}

void WriteOutput(const AST* ast, char** outBuffer, size_t* outLength)
{
	indentationLevel = 0;

	sections = AllocateMemoryStream();
	descriptionLines = AllocateMemoryStream();

	WriteString("tabsize: ", descriptionLines);
	WriteUInt64(INDENT_WIDTH, descriptionLines);
	WriteChar('\n', descriptionLines);

	for (size_t i = 0; i < ast->nodes.length; ++i)
	{
		const NodePtr* node = ast->nodes.array[i];
		ASSERT(node->type == Node_Module);
		WriteModule(node->ptr);
	}

	MemoryStream* main = AllocateMemoryStream();
	WriteString(watermark, main);
	StreamWriteByte(main, '\n');
	StreamWriteStream(main, descriptionLines);
	StreamWriteByte(main, '\n');
	StreamWriteStream(main, sections);

	FreeMemoryStream(descriptionLines, true);
	FreeMemoryStream(sections, true);

	if (outBuffer != NULL) *outBuffer = StreamGetBuffer(main).buffer;
	if (outLength != NULL) *outLength = StreamGetBuffer(main).length;
	FreeMemoryStream(main, false);
}
