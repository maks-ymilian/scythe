import "Math.scy"
import "Time.scy"
import "Models.scy"
import "Depth.scy"

desc [
	description: "3D Renderer",
	in_pins: [pin: "none"],
	out_pins: [pin: "none"],
	options: [
		gfx: [hz: 120],
	],
];

input modelInput [name: "model", default: 2, min: 0, max: 2, inc: 1];
input resolution [name: "3D resolution (%)", default: 90, min: 0, max: 100, inc: 1, shape: [type: log, midpoint: 70]];
input smooth [name: "smooth shading", default: 1, min: 0, max: 1, inc: 1];
input showNormals [name: "show normals", default: 0, min: 0, max: 1, inc: 1];
input stop [name: "stop", default: 0, min: 0, max: 1, inc: 1];

input shininess [name: "shininess", default: 16, min: 1, max: 100, shape: [type: log, midpoint: 30]];
input lightPower [name: "light power", default: 2, min: 0, max: 5];
input ambientLight [name: "ambient light", default: 0.005, min: 0, max: 1, shape: [type: log, midpoint: 0.01]];
input lightPos [name: "light position", default: 65, min: 0, max: 360];

struct Color
{
	float r;
	float g;
	float b;
}

struct Triangle3D
{
	Math.Vec3 v1;
	Math.Vec3 v2;
	Math.Vec3 v3;

	Math.Vec3 n1;
	Math.Vec3 n2;
	Math.Vec3 n3;
}

struct Triangle4D
{
	Math.Vec4 v1;
	Math.Vec4 v2;
	Math.Vec4 v3;

	Math.Vec3 n1;
	Math.Vec3 n2;
	Math.Vec3 n3;
}

// this is equal to gfx.w and gfx.h if resolution slider is 100%, otherwise its smalller
int width;
int height;

// this is equal to 1 if resolution slider is 100%, otherwise its bigger
int pixelSize;

// sets a pixel to a color
// since resolution slider scales down the image, this function scales it back up
void SetPixel(int x, int y, Color color)
{
	y = height - y; // flip y

	if (pixelSize == 1) // if max resolution
	{
		gfx.setpos(x * pixelSize, y * pixelSize);
		gfx.setpixel(color.r, color.g, color.b);
	}
	else
	{
		gfx.set(color.r, color.g, color.b);
		gfx.rect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
	}
}

// "fragment shader"
// calculates the color of the current pixel using the world position and normal of the current pixel
Color ComputeFragmentColor(Math.Vec3 pos, Math.Vec3 normal)
{
	if (showNormals.value == 1)
		return Color {.r = normal.x, .g = normal.y, .b = normal.z};

	float gamma = 2.2;

	Math.Vec3 lightPos = Math.Vec3 {
		.x = 0,
		.y = math.cos(Math.Deg2Rad(lightPos.value)) * 3,
		.z = math.sin(Math.Deg2Rad(lightPos.value)) * 3 - 3,
	};

	Math.Vec3 lightDir = Math.Subtract3D(lightPos, pos);
	float distance = Math.Dot3D(lightDir, lightDir);
	lightDir = Math.Normalize3D(lightDir);

	float diffuse = math.max(Math.Dot3D(lightDir, normal), 0);

	// blinn phong
	float specular = float {
		Math.Vec3 viewDir = Math.Normalize3D(Math.Subtract3D(Math.Vec3 {}, pos));
		Math.Vec3 halfDir = Math.Normalize3D(Math.Add3D(lightDir, viewDir));
		float specAngle = math.max(Math.Dot3D(halfDir, normal), 0);
		return math.pow(specAngle, shininess.value);
	};

	float color =
		ambientLight.value +
		diffuse * lightPower.value / distance +
		specular * diffuse * lightPower.value / distance;

	color = math.pow(color, 1 / gamma);

	return Color {.r = color, .g = color, .b = color};
}

// draw a 2d triangle on the screen. the z values are kept for depth calculation
void DrawTriangle(Triangle3D t, Triangle4D world)
{
	Math.Vec2 Vec3To2(Math.Vec3 v) { return Math.Vec2 {.x = v.x, .y = v.y}; }

	// if triangle is facing away from the camera, dont render it
	if (!Math.CheckWindingOrder(Vec3To2(t.v1), Vec3To2(t.v2), Vec3To2(t.v3)))
		return;

	// get bounding box of triangle and loop through each pixel in the bounding box
	Math.Bounds bounds = Math.GetTriangleBounds(Vec3To2(t.v1), Vec3To2(t.v2), Vec3To2(t.v3));
	for (int x = bounds.min.x; x < bounds.max.x; ++x)
	{
		for (int y = bounds.min.y; y < bounds.max.y; ++y)
		{
			// if the pixel in the bounding box is not in the triangle, dont render it
			if (!Math.PointInTriangle(Vec3To2(t.v1), Vec3To2(t.v2), Vec3To2(t.v3), Math.Vec2 {.x = x, .y = y}))
				continue;

			// get 3 weighted values for how close this pixel is to each vertex of the triangle
			Math.Vec3 barycentric = Math.GetBarycentricCoordinates(Vec3To2(t.v1), Vec3To2(t.v2), Vec3To2(t.v3), Math.Vec2 {.x = x, .y = y});

			// get depth of the current pixel by interpolating the depth of the 3 vertices
			float depth =
					((t.v1.z + 1) / 2) * barycentric.x + 
					((t.v2.z + 1) / 2) * barycentric.y +
					((t.v3.z + 1) / 2) * barycentric.z;
			if (depth > Depth.GetDepth(x, y)) // if the current pixel is behind an already drawn pixel, dont render it
				continue;
			Depth.SetDepth(x, y, depth); // update depth for this pixel

			Math.Vec3 normal = Math.Vec3 {
				if (smooth.value == 1) // if smooth shading is on, calculate a normal for this pixel interpolated from 3 vertex normals
				{
					Math.Vec3 n1 = Math.Vec3 {.x = t.n1.x * barycentric.x, .y = t.n1.y * barycentric.x, .z = t.n1.z * barycentric.x};
					Math.Vec3 n2 = Math.Vec3 {.x = t.n2.x * barycentric.y, .y = t.n2.y * barycentric.y, .z = t.n2.z * barycentric.y};
					Math.Vec3 n3 = Math.Vec3 {.x = t.n3.x * barycentric.z, .y = t.n3.y * barycentric.z, .z = t.n3.z * barycentric.z};
					return Math.Normalize3D(Math.Add3D(Math.Add3D(n1, n2), n3));
				}
				else // if smooth shading is off, use the average of all 3 vertex normals
					return Math.Normalize3D(Math.Add3D(Math.Add3D(t.n1, t.n2), t.n3));
			};

			// get world pos of pixel
			Math.Vec3 worldPos = Math.Vec3 {
				.x = world.v1.x * barycentric.x + world.v2.x * barycentric.y + world.v3.x * barycentric.z,
				.y = world.v1.y * barycentric.x + world.v2.y * barycentric.y + world.v3.y * barycentric.z,
				.z = world.v1.z * barycentric.x + world.v2.z * barycentric.y + world.v3.z * barycentric.z,
			};

			Color color = ComputeFragmentColor(worldPos, normal);
			SetPixel(x, y, color);
		}
	}
}

// transform vertices of triangle with matrix
Triangle4D TransformPositions(Triangle4D t, Math.Mat4 m)
{
	return Triangle4D {
		.v1 = Math.MultiplyVec4Mat4(t.v1, m),
		.v2 = Math.MultiplyVec4Mat4(t.v2, m),
		.v3 = Math.MultiplyVec4Mat4(t.v3, m),
		.n1 = t.n1,
		.n2 = t.n2,
		.n3 = t.n3,
	};
}

// transform normals of triangle with matrix
Triangle4D TransformNormals(Triangle4D t, Math.Mat4 m)
{
	// model matrix needs to be inverted, transposed, and cropped before being applied to normals
	Math.Mat3 normalMatrix = Math.Mat4ToMat3(Math.TransposeMat4(Math.InverseMat4(m)));
	return Triangle4D {
		.v1 = t.v1,
		.v2 = t.v2,
		.v3 = t.v3,
		.n1 = Math.MultiplyVec3Mat3(t.n1, normalMatrix),
		.n2 = Math.MultiplyVec3Mat3(t.n2, normalMatrix),
		.n3 = Math.MultiplyVec3Mat3(t.n3, normalMatrix),
	};
}

// arranges data from model into a Triangle4D struct for ease of use
Triangle4D GetModelTriangle(Models.Model model, int triangle)
{
	Math.Vec3 v1 = model.vertices[model.triangles[triangle].v1];
	Math.Vec3 v2 = model.vertices[model.triangles[triangle].v2];
	Math.Vec3 v3 = model.vertices[model.triangles[triangle].v3];

	Math.Vec3 n1 = model.normals[model.triangles[triangle].n1];
	Math.Vec3 n2 = model.normals[model.triangles[triangle].n2];
	Math.Vec3 n3 = model.normals[model.triangles[triangle].n3];

	return Triangle4D {
		.v1 = Math.Vec4 {.x = v1.x, .y = v1.y, .z = v1.z, .w = 1},
		.v2 = Math.Vec4 {.x = v2.x, .y = v2.y, .z = v2.z, .w = 1},
		.v3 = Math.Vec4 {.x = v3.x, .y = v3.y, .z = v3.z, .w = 1},
		.n1 = n1, .n2 = n2, .n3 = n3,
	};
}

// allocate model depending on slider
Models.Model model;
int AllocModel(any* ptr)
{
	if (modelInput.value == 0) model = Models.Cube(ptr);
	else if (modelInput.value == 1) model = Models.Torus(ptr);
	else if (modelInput.value == 2) model = Models.Monkey(ptr);
	else model = Models.Torus(ptr);
	
	return Models.GetModelSize(model);
}

// this is called every time the model changes, every time the resolution changes, and at start
Math.Mat4 proj;
void Init()
{
	// set pixel size based on resolution slider. pixel size 1 is maximum resolution
	pixelSize = (1 - math.lerp(0.95, 1, resolution.value / 100)) * math.min(gfx.w, gfx.h);
	if (pixelSize == 0) pixelSize = 1;

	// scale screen size down if resolution is lowered.
	// the final image will be scaled up to full screen size in the SetPixel function
	width = int {gfx.w / pixelSize};
	height = int {gfx.h / pixelSize};

	// allocate projection matrix based on fov, aspect ratio, near plane, and far plane
	proj = Math.ProjectionMatrix(Math.Deg2Rad(70), width / height, 0.1, 100);

	// allocate depth buffer for new screen size and current model directly after it in memory
	any* stackPtr = 0;
	stackPtr += Depth.AllocDepthBuffer(stackPtr, width, height);
	stackPtr += AllocModel(stackPtr);
	mem.freembuf(stackPtr); // tell reaper that memory at and after this point is not used
}

// call init every time a slider changes and at startup
@slider
{
	Init();
}

Math.Vec3 currentRotation;
int prevWidth;
int prevHeight;
@gfx [width: 512, height: 512]
{
	SetPixel(0, 0, Color {}); // force update because jsfx will hang on the previous frame if nothing is drawn that frame

	// call init every time window is resized and on first frame
	if (gfx.w != prevWidth || gfx.h != prevHeight)
		Init();
	prevWidth = gfx.w;
	prevHeight = gfx.h;

	Depth.FillDepthBuffer(1); // initialize whole depth buffer to far

	float deltaTime = Time.ComputeDeltaTime(); // get the time since last frame

	// make it spin
	if (stop.value == 0)
	{
		currentRotation.x += deltaTime * 0.5;
		currentRotation.y += deltaTime * 2;
		currentRotation.z += deltaTime * 0.5;
	}

	// model matrix can be used to position, rotate, and scale a model
	Math.Mat4 modelMatrix = Math.ModelMatrix(
		Math.Vec3 {.z = -3}, // position
		Math.RotationMatrixEuler(currentRotation), // rotation
		Math.Vec3 {.x = 1, .y = 1, .z = 1}, // scale
	);

	// loop through each triangle in the model, transform it, and draw it to the screen
	for (int i = 0; i < model.triangles.length; ++i)
	{
		// get current triangle, starts off in object space
		Triangle4D object = GetModelTriangle(model, i);

		// transform triangle to world space (position, rotation, scaling)
		Triangle4D world = TransformPositions(object, modelMatrix);
		world = TransformNormals(world, modelMatrix);

		// transform triangle to clip space (projection)
		// frustum clipping is supposed to happen here but is not needed for this demo
		Triangle4D clip = TransformPositions(world, proj);

		// transform triangle to ndc space (homogeneous division)
		Math.Vec3 DivideW(Math.Vec4 v)
		{
			v.x /= v.w;
			v.y /= v.w;
			v.z /= v.w;
			return Math.Vec3 {.x = v.x, .y = v.y, .z = v.z};
		}
		Triangle3D ndc = Triangle3D {
			.v1 = DivideW(clip.v1),
			.v2 = DivideW(clip.v2),
			.v3 = DivideW(clip.v3),
			.n1 = clip.n1,
			.n2 = clip.n2,
			.n3 = clip.n3,
		};

		// transform triangle to screen space (pixels)
		Math.Vec3 NDCToScreen(Math.Vec3 ndc)
		{
			return Math.Vec3 {
				.x = ndc.x * width / 2 + width / 2,
				.y = ndc.y * height / 2 + height / 2,
				.z = ndc.z,
			};
		}
		Triangle3D screen = Triangle3D {
			.v1 = NDCToScreen(ndc.v1),
			.v2 = NDCToScreen(ndc.v2),
			.v3 = NDCToScreen(ndc.v3),
			.n1 = ndc.n1,
			.n2 = ndc.n2,
			.n3 = ndc.n3,
		};

		DrawTriangle(screen, world);
	}

	// draw fps text
	string fpsString = 0;
	int fps = math.round(1 / deltaTime);
	str.sprintf(fpsString, "%.0f FPS\n", fps);
	gfx.setpos(10, 10);
	gfx.set(1, 1, 1);
	gfx.setfont(1, "Arial", 30);
	gfx.drawstr(fpsString);
}
